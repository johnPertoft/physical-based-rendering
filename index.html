<html>
<head>
<title>Physically Based Rendering Demo</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.2/lodash.min.js"></script>
</head>
<body>
<div id="container" width="100%" height="100%"></div>
<!--<canvas id="canvas" width="100%" height="100%"></canvas>-->
<script>
const NEAR = 0.1;
const FAR = 10000;
const VIEW_ANGLE = 45;

const WIDTH = 800;
const HEIGHT = 600;
const ASPECT = WIDTH / HEIGHT;

const renderer = new THREE.WebGLRenderer();
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    VIEW_ANGLE,
    ASPECT,
    NEAR,
    FAR);

scene.add(camera);
camera.position.z = 300;
renderer.setSize(WIDTH, HEIGHT);
document.body.appendChild(renderer.domElement);

// TODO: write a small loader for shaders instead
let vShaderSource = `
attribute float displacement;
varying vec3 norm;
void main() {
  norm = normal;
  vec3 newPosition = position + vec3(displacement) * normal;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
}
`

let fShaderSource = `
varying vec3 norm;
void main() {
  vec3 light = vec3(0.5, 0.2, 1.0);
  light = normalize(light);
  float dProd = max(0.0, dot(norm, light));
  gl_FragColor = vec4(dProd, dProd, dProd, 1.0);
}
`

// Temp, just drawing something
let radius = 50;
let segments = 64;
let rings = 64;
let lambertMaterial = new THREE.MeshLambertMaterial({color: 0xCC0000});
let phongMaterial = new THREE.MeshPhongMaterial({color: 0xCCAA00});
let customMaterial = new THREE.ShaderMaterial(
    {
      vertexShader: vShaderSource,
      fragmentShader: fShaderSource
    }
);

let sphereMaterial = customMaterial;

let sphere = new THREE.Mesh(
    new THREE.SphereGeometry(radius, segments, rings),
    sphereMaterial);

scene.add(sphere);

let pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;

scene.add(pointLight);

const renderLoop = (t) => {
  scale = 0.5 + Math.abs(Math.sin(t / 1000));
  sphere.scale.x = 1 * scale;
  sphere.scale.y = 1 * scale;
  sphere.scale.z = 1 * scale;
  
  renderer.render(scene, camera);
  requestAnimationFrame(renderLoop);
};

requestAnimationFrame(renderLoop);

</script>
</body>
</html>
